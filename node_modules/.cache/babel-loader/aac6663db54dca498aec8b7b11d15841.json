{"ast":null,"code":"export function splitArgsAndCtx(idlIx, args) {\n  var _a, _b;\n\n  let options = {};\n  const inputLen = idlIx.args ? idlIx.args.length : 0;\n\n  if (args.length > inputLen) {\n    if (args.length !== inputLen + 1) {\n      throw new Error(`provided too many arguments ${args} to instruction ${idlIx === null || idlIx === void 0 ? void 0 : idlIx.name} expecting: ${(_b = (_a = idlIx.args) === null || _a === void 0 ? void 0 : _a.map(a => a.name)) !== null && _b !== void 0 ? _b : []}`);\n    }\n\n    options = args.pop();\n  }\n\n  return [args, options];\n}","map":{"version":3,"sources":["/root/mysolanaapp2/app/node_modules/@project-serum/anchor/src/program/context.ts"],"names":[],"mappings":"AAiEA,OAAM,SAAU,eAAV,CACJ,KADI,EAEJ,IAFI,EAEO;;;AAEX,MAAI,OAAO,GAAG,EAAd;AAEA,QAAM,QAAQ,GAAG,KAAK,CAAC,IAAN,GAAa,KAAK,CAAC,IAAN,CAAW,MAAxB,GAAiC,CAAlD;;AACA,MAAI,IAAI,CAAC,MAAL,GAAc,QAAlB,EAA4B;AAC1B,QAAI,IAAI,CAAC,MAAL,KAAgB,QAAQ,GAAG,CAA/B,EAAkC;AAChC,YAAM,IAAI,KAAJ,CACJ,+BAA+B,IAAI,mBACjC,KAAK,KAAA,IAAL,IAAA,KAAK,KAAA,KAAA,CAAL,GAAK,KAAA,CAAL,GAAA,KAAK,CAAE,IACT,eAAe,CAAA,EAAA,GAAA,CAAA,EAAA,GAAA,KAAK,CAAC,IAAN,MAAU,IAAV,IAAU,EAAA,KAAA,KAAA,CAAV,GAAU,KAAA,CAAV,GAAU,EAAA,CAAE,GAAF,CAAO,CAAD,IAAO,CAAC,CAAC,IAAf,CAAV,MAA8B,IAA9B,IAA8B,EAAA,KAAA,KAAA,CAA9B,GAA8B,EAA9B,GAAkC,EAAE,EAH/C,CAAN;AAKD;;AACD,IAAA,OAAO,GAAG,IAAI,CAAC,GAAL,EAAV;AACD;;AAED,SAAO,CAAC,IAAD,EAAO,OAAP,CAAP;AACD","sourcesContent":["import {\n  AccountMeta,\n  Signer,\n  ConfirmOptions,\n  TransactionInstruction,\n} from \"@solana/web3.js\";\nimport { Address } from \"./common\";\nimport { IdlAccountItem, IdlAccounts, IdlInstruction } from \"../idl\";\n\n/**\n * Context provides all non-argument inputs for generating Anchor transactions.\n */\nexport type Context<A extends Accounts = Accounts> = {\n  /**\n   * Accounts used in the instruction context.\n   */\n  accounts?: A;\n\n  /**\n   * All accounts to pass into an instruction *after* the main `accounts`.\n   * This can be used for optional or otherwise unknown accounts.\n   */\n  remainingAccounts?: AccountMeta[];\n\n  /**\n   * Accounts that must sign a given transaction.\n   */\n  signers?: Array<Signer>;\n\n  /**\n   * Instructions to run *before* a given method. Often this is used, for\n   * example to create accounts prior to executing a method.\n   */\n  instructions?: TransactionInstruction[];\n\n  /**\n   * Commitment parameters to use for a transaction.\n   */\n  options?: ConfirmOptions;\n\n  /**\n   * @hidden\n   *\n   * Private namespace for development.\n   */\n  __private?: { logAccounts: boolean };\n};\n\n/**\n * A set of accounts mapping one-to-one to the program's accounts struct, i.e.,\n * the type deriving `#[derive(Accounts)]`.\n *\n * The name of each field should match the name for that account in the IDL.\n *\n * If multiple accounts are nested in the rust program, then they should be\n * nested here.\n */\nexport type Accounts<A extends IdlAccountItem = IdlAccountItem> = {\n  [N in A[\"name\"]]: Account<A & { name: N }>;\n};\n\ntype Account<A extends IdlAccountItem> = A extends IdlAccounts\n  ? Accounts<A[\"accounts\"][number]>\n  : Address;\n\nexport function splitArgsAndCtx(\n  idlIx: IdlInstruction,\n  args: any[]\n): [any[], Context] {\n  let options = {};\n\n  const inputLen = idlIx.args ? idlIx.args.length : 0;\n  if (args.length > inputLen) {\n    if (args.length !== inputLen + 1) {\n      throw new Error(\n        `provided too many arguments ${args} to instruction ${\n          idlIx?.name\n        } expecting: ${idlIx.args?.map((a) => a.name) ?? []}`\n      );\n    }\n    options = args.pop();\n  }\n\n  return [args, options];\n}\n"]},"metadata":{},"sourceType":"module"}
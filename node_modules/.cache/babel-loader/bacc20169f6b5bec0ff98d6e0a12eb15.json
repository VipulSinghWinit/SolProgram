{"ast":null,"code":"import { PublicKey } from \"@solana/web3.js\";\nimport * as borsh from \"@project-serum/borsh\"; // Deterministic IDL address as a function of the program id.\n\nexport async function idlAddress(programId) {\n  const base = (await PublicKey.findProgramAddress([], programId))[0];\n  return await PublicKey.createWithSeed(base, seed(), programId);\n} // Seed for generating the idlAddress.\n\nexport function seed() {\n  return \"anchor:idl\";\n}\nconst IDL_ACCOUNT_LAYOUT = borsh.struct([borsh.publicKey(\"authority\"), borsh.vecU8(\"data\")]);\nexport function decodeIdlAccount(data) {\n  return IDL_ACCOUNT_LAYOUT.decode(data);\n}\nexport function encodeIdlAccount(acc) {\n  const buffer = Buffer.alloc(1000); // TODO: use a tighter buffer.\n\n  const len = IDL_ACCOUNT_LAYOUT.encode(acc, buffer);\n  return buffer.slice(0, len);\n}","map":{"version":3,"sources":["/root/mysolanaapp2/app/node_modules/@project-serum/anchor/src/idl.ts"],"names":[],"mappings":"AAAA,SAAS,SAAT,QAA0B,iBAA1B;AACA,OAAO,KAAK,KAAZ,MAAuB,sBAAvB,C,CAiIA;;AACA,OAAO,eAAe,UAAf,CAA0B,SAA1B,EAA8C;AACnD,QAAM,IAAI,GAAG,CAAC,MAAM,SAAS,CAAC,kBAAV,CAA6B,EAA7B,EAAiC,SAAjC,CAAP,EAAoD,CAApD,CAAb;AACA,SAAO,MAAM,SAAS,CAAC,cAAV,CAAyB,IAAzB,EAA+B,IAAI,EAAnC,EAAuC,SAAvC,CAAb;AACD,C,CAED;;AACA,OAAM,SAAU,IAAV,GAAc;AAClB,SAAO,YAAP;AACD;AAQD,MAAM,kBAAkB,GAAoC,KAAK,CAAC,MAAN,CAAa,CACvE,KAAK,CAAC,SAAN,CAAgB,WAAhB,CADuE,EAEvE,KAAK,CAAC,KAAN,CAAY,MAAZ,CAFuE,CAAb,CAA5D;AAKA,OAAM,SAAU,gBAAV,CAA2B,IAA3B,EAAuC;AAC3C,SAAO,kBAAkB,CAAC,MAAnB,CAA0B,IAA1B,CAAP;AACD;AAED,OAAM,SAAU,gBAAV,CAA2B,GAA3B,EAAiD;AACrD,QAAM,MAAM,GAAG,MAAM,CAAC,KAAP,CAAa,IAAb,CAAf,CADqD,CAClB;;AACnC,QAAM,GAAG,GAAG,kBAAkB,CAAC,MAAnB,CAA0B,GAA1B,EAA+B,MAA/B,CAAZ;AACA,SAAO,MAAM,CAAC,KAAP,CAAa,CAAb,EAAgB,GAAhB,CAAP;AACD","sourcesContent":["import { PublicKey } from \"@solana/web3.js\";\nimport * as borsh from \"@project-serum/borsh\";\n\nexport type Idl = {\n  version: string;\n  name: string;\n  instructions: IdlInstruction[];\n  state?: IdlState;\n  accounts?: IdlTypeDef[];\n  types?: IdlTypeDef[];\n  events?: IdlEvent[];\n  errors?: IdlErrorCode[];\n};\n\nexport type IdlEvent = {\n  name: string;\n  fields: IdlEventField[];\n};\n\nexport type IdlEventField = {\n  name: string;\n  type: IdlType;\n  index: boolean;\n};\n\nexport type IdlInstruction = {\n  name: string;\n  accounts: IdlAccountItem[];\n  args: IdlField[];\n};\n\nexport type IdlState = {\n  struct: IdlTypeDef;\n  methods: IdlStateMethod[];\n};\n\nexport type IdlStateMethod = IdlInstruction;\n\nexport type IdlAccountItem = IdlAccount | IdlAccounts;\n\nexport type IdlAccount = {\n  name: string;\n  isMut: boolean;\n  isSigner: boolean;\n};\n\n// A nested/recursive version of IdlAccount.\nexport type IdlAccounts = {\n  name: string;\n  accounts: IdlAccountItem[];\n};\n\nexport type IdlField = {\n  name: string;\n  type: IdlType;\n};\n\nexport type IdlTypeDef = {\n  name: string;\n  type: IdlTypeDefTy;\n};\n\nexport type IdlTypeDefTyStruct = {\n  kind: \"struct\";\n  fields: IdlTypeDefStruct;\n};\n\nexport type IdlTypeDefTyEnum = {\n  kind: \"enum\";\n  variants: IdlEnumVariant[];\n};\n\ntype IdlTypeDefTy = IdlTypeDefTyEnum | IdlTypeDefTyStruct;\n\ntype IdlTypeDefStruct = Array<IdlField>;\n\nexport type IdlType =\n  | \"bool\"\n  | \"u8\"\n  | \"i8\"\n  | \"u16\"\n  | \"i16\"\n  | \"u32\"\n  | \"i32\"\n  | \"u64\"\n  | \"i64\"\n  | \"u128\"\n  | \"i128\"\n  | \"bytes\"\n  | \"string\"\n  | \"publicKey\"\n  | IdlTypeDefined\n  | IdlTypeOption\n  | IdlTypeVec\n  | IdlTypeArray;\n\n// User defined type.\nexport type IdlTypeDefined = {\n  defined: string;\n};\n\nexport type IdlTypeOption = {\n  option: IdlType;\n};\n\nexport type IdlTypeVec = {\n  vec: IdlType;\n};\n\nexport type IdlTypeArray = {\n  array: [idlType: IdlType, size: number];\n};\n\nexport type IdlEnumVariant = {\n  name: string;\n  fields?: IdlEnumFields;\n};\n\ntype IdlEnumFields = IdlEnumFieldsNamed | IdlEnumFieldsTuple;\n\ntype IdlEnumFieldsNamed = IdlField[];\n\ntype IdlEnumFieldsTuple = IdlType[];\n\nexport type IdlErrorCode = {\n  code: number;\n  name: string;\n  msg?: string;\n};\n\n// Deterministic IDL address as a function of the program id.\nexport async function idlAddress(programId: PublicKey): Promise<PublicKey> {\n  const base = (await PublicKey.findProgramAddress([], programId))[0];\n  return await PublicKey.createWithSeed(base, seed(), programId);\n}\n\n// Seed for generating the idlAddress.\nexport function seed(): string {\n  return \"anchor:idl\";\n}\n\n// The on-chain account of the IDL.\nexport interface IdlProgramAccount {\n  authority: PublicKey;\n  data: Buffer;\n}\n\nconst IDL_ACCOUNT_LAYOUT: borsh.Layout<IdlProgramAccount> = borsh.struct([\n  borsh.publicKey(\"authority\"),\n  borsh.vecU8(\"data\"),\n]);\n\nexport function decodeIdlAccount(data: Buffer): IdlProgramAccount {\n  return IDL_ACCOUNT_LAYOUT.decode(data);\n}\n\nexport function encodeIdlAccount(acc: IdlProgramAccount): Buffer {\n  const buffer = Buffer.alloc(1000); // TODO: use a tighter buffer.\n  const len = IDL_ACCOUNT_LAYOUT.encode(acc, buffer);\n  return buffer.slice(0, len);\n}\n"]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import { TransactionInstruction } from \"@solana/web3.js\";\nimport { IdlError } from \"../../error\";\nimport { toInstruction, validateAccounts, translateAddress } from \"../common\";\nimport { splitArgsAndCtx } from \"../context\";\nexport default class InstructionNamespaceFactory {\n  static build(idlIx, encodeFn, programId) {\n    if (idlIx.name === \"_inner\") {\n      throw new IdlError(\"the _inner name is reserved\");\n    }\n\n    const ix = function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      const [ixArgs, ctx] = splitArgsAndCtx(idlIx, [...args]);\n      validateAccounts(idlIx.accounts, ctx.accounts);\n      validateInstruction(idlIx, ...args);\n      const keys = ix.accounts(ctx.accounts);\n\n      if (ctx.remainingAccounts !== undefined) {\n        keys.push(...ctx.remainingAccounts);\n      }\n\n      if (ctx.__private && ctx.__private.logAccounts) {\n        console.log(\"Outgoing account metas:\", keys);\n      }\n\n      return new TransactionInstruction({\n        keys,\n        programId,\n        data: encodeFn(idlIx.name, toInstruction(idlIx, ...ixArgs))\n      });\n    }; // Utility fn for ordering the accounts for this instruction.\n\n\n    ix[\"accounts\"] = accs => {\n      return InstructionNamespaceFactory.accountsArray(accs, idlIx.accounts);\n    };\n\n    return ix;\n  }\n\n  static accountsArray(ctx, accounts) {\n    if (!ctx) {\n      return [];\n    }\n\n    return accounts.map(acc => {\n      // Nested accounts.\n      const nestedAccounts = \"accounts\" in acc ? acc.accounts : undefined;\n\n      if (nestedAccounts !== undefined) {\n        const rpcAccs = ctx[acc.name];\n        return InstructionNamespaceFactory.accountsArray(rpcAccs, acc.accounts).flat();\n      } else {\n        const account = acc;\n        return {\n          pubkey: translateAddress(ctx[acc.name]),\n          isWritable: account.isMut,\n          isSigner: account.isSigner\n        };\n      }\n    }).flat();\n  }\n\n} // Throws error if any argument required for the `ix` is not given.\n\nfunction validateInstruction(ix) {// todo\n}","map":{"version":3,"sources":["/root/mysolanaapp2/app/node_modules/@project-serum/anchor/src/program/namespace/instruction.ts"],"names":[],"mappings":"AAAA,SAGE,sBAHF,QAIO,iBAJP;AAYA,SAAS,QAAT,QAAyB,aAAzB;AACA,SACE,aADF,EAEE,gBAFF,EAGE,gBAHF,QAKO,WALP;AAMA,SAAmB,eAAnB,QAA0C,YAA1C;AASA,eAAc,MAAO,2BAAP,CAAkC;AAC3B,SAAL,KAAK,CACjB,KADiB,EAEjB,QAFiB,EAGjB,SAHiB,EAGG;AAEpB,QAAI,KAAK,CAAC,IAAN,KAAe,QAAnB,EAA6B;AAC3B,YAAM,IAAI,QAAJ,CAAa,6BAAb,CAAN;AACD;;AAED,UAAM,EAAE,GAAG,YAEiB;AAAA,wCADvB,IACuB;AADvB,QAAA,IACuB;AAAA;;AAC1B,YAAM,CAAC,MAAD,EAAS,GAAT,IAAgB,eAAe,CAAC,KAAD,EAAQ,CAAC,GAAG,IAAJ,CAAR,CAArC;AACA,MAAA,gBAAgB,CAAC,KAAK,CAAC,QAAP,EAAiB,GAAG,CAAC,QAArB,CAAhB;AACA,MAAA,mBAAmB,CAAC,KAAD,EAAQ,GAAG,IAAX,CAAnB;AAEA,YAAM,IAAI,GAAG,EAAE,CAAC,QAAH,CAAY,GAAG,CAAC,QAAhB,CAAb;;AAEA,UAAI,GAAG,CAAC,iBAAJ,KAA0B,SAA9B,EAAyC;AACvC,QAAA,IAAI,CAAC,IAAL,CAAU,GAAG,GAAG,CAAC,iBAAjB;AACD;;AAED,UAAI,GAAG,CAAC,SAAJ,IAAiB,GAAG,CAAC,SAAJ,CAAc,WAAnC,EAAgD;AAC9C,QAAA,OAAO,CAAC,GAAR,CAAY,yBAAZ,EAAuC,IAAvC;AACD;;AACD,aAAO,IAAI,sBAAJ,CAA2B;AAChC,QAAA,IADgC;AAEhC,QAAA,SAFgC;AAGhC,QAAA,IAAI,EAAE,QAAQ,CAAC,KAAK,CAAC,IAAP,EAAa,aAAa,CAAC,KAAD,EAAQ,GAAG,MAAX,CAA1B;AAHkB,OAA3B,CAAP;AAKD,KArBD,CANoB,CA6BpB;;;AACA,IAAA,EAAE,CAAC,UAAD,CAAF,GAAkB,IAAD,IAAsD;AACrE,aAAO,2BAA2B,CAAC,aAA5B,CAA0C,IAA1C,EAAgD,KAAK,CAAC,QAAtD,CAAP;AACD,KAFD;;AAIA,WAAO,EAAP;AACD;;AAE0B,SAAb,aAAa,CACzB,GADyB,EAEzB,QAFyB,EAEU;AAEnC,QAAI,CAAC,GAAL,EAAU;AACR,aAAO,EAAP;AACD;;AAED,WAAO,QAAQ,CACZ,GADI,CACC,GAAD,IAAwB;AAC3B;AACA,YAAM,cAAc,GAClB,cAAc,GAAd,GAAoB,GAAG,CAAC,QAAxB,GAAmC,SADrC;;AAEA,UAAI,cAAc,KAAK,SAAvB,EAAkC;AAChC,cAAM,OAAO,GAAG,GAAG,CAAC,GAAG,CAAC,IAAL,CAAnB;AACA,eAAO,2BAA2B,CAAC,aAA5B,CACL,OADK,EAEJ,GAAmB,CAAC,QAFhB,EAGL,IAHK,EAAP;AAID,OAND,MAMO;AACL,cAAM,OAAO,GAAe,GAA5B;AACA,eAAO;AACL,UAAA,MAAM,EAAE,gBAAgB,CAAC,GAAG,CAAC,GAAG,CAAC,IAAL,CAAJ,CADnB;AAEL,UAAA,UAAU,EAAE,OAAO,CAAC,KAFf;AAGL,UAAA,QAAQ,EAAE,OAAO,CAAC;AAHb,SAAP;AAKD;AACF,KAnBI,EAoBJ,IApBI,EAAP;AAqBD;;AAtE6C,C,CA6IhD;;AACA,SAAS,mBAAT,CAA6B,EAA7B,EAA+D,CAC7D;AACD","sourcesContent":["import {\n  AccountMeta,\n  PublicKey,\n  TransactionInstruction,\n} from \"@solana/web3.js\";\nimport {\n  Idl,\n  IdlAccount,\n  IdlAccountItem,\n  IdlAccounts,\n  IdlInstruction,\n} from \"../../idl\";\nimport { IdlError } from \"../../error\";\nimport {\n  toInstruction,\n  validateAccounts,\n  translateAddress,\n  Address,\n} from \"../common\";\nimport { Accounts, splitArgsAndCtx } from \"../context\";\nimport {\n  AllInstructions,\n  AllInstructionsMap,\n  InstructionContextFn,\n  InstructionContextFnArgs,\n  MakeInstructionsNamespace,\n} from \"./types\";\n\nexport default class InstructionNamespaceFactory {\n  public static build<IDL extends Idl, I extends AllInstructions<IDL>>(\n    idlIx: I,\n    encodeFn: InstructionEncodeFn<I>,\n    programId: PublicKey\n  ): InstructionFn<IDL, I> {\n    if (idlIx.name === \"_inner\") {\n      throw new IdlError(\"the _inner name is reserved\");\n    }\n\n    const ix = (\n      ...args: InstructionContextFnArgs<IDL, I>\n    ): TransactionInstruction => {\n      const [ixArgs, ctx] = splitArgsAndCtx(idlIx, [...args]);\n      validateAccounts(idlIx.accounts, ctx.accounts);\n      validateInstruction(idlIx, ...args);\n\n      const keys = ix.accounts(ctx.accounts);\n\n      if (ctx.remainingAccounts !== undefined) {\n        keys.push(...ctx.remainingAccounts);\n      }\n\n      if (ctx.__private && ctx.__private.logAccounts) {\n        console.log(\"Outgoing account metas:\", keys);\n      }\n      return new TransactionInstruction({\n        keys,\n        programId,\n        data: encodeFn(idlIx.name, toInstruction(idlIx, ...ixArgs)),\n      });\n    };\n\n    // Utility fn for ordering the accounts for this instruction.\n    ix[\"accounts\"] = (accs: Accounts<I[\"accounts\"][number]> | undefined) => {\n      return InstructionNamespaceFactory.accountsArray(accs, idlIx.accounts);\n    };\n\n    return ix;\n  }\n\n  public static accountsArray(\n    ctx: Accounts | undefined,\n    accounts: readonly IdlAccountItem[]\n  ): AccountMeta[] {\n    if (!ctx) {\n      return [];\n    }\n\n    return accounts\n      .map((acc: IdlAccountItem) => {\n        // Nested accounts.\n        const nestedAccounts: IdlAccountItem[] | undefined =\n          \"accounts\" in acc ? acc.accounts : undefined;\n        if (nestedAccounts !== undefined) {\n          const rpcAccs = ctx[acc.name] as Accounts;\n          return InstructionNamespaceFactory.accountsArray(\n            rpcAccs,\n            (acc as IdlAccounts).accounts\n          ).flat();\n        } else {\n          const account: IdlAccount = acc as IdlAccount;\n          return {\n            pubkey: translateAddress(ctx[acc.name] as Address),\n            isWritable: account.isMut,\n            isSigner: account.isSigner,\n          };\n        }\n      })\n      .flat();\n  }\n}\n\n/**\n * The namespace provides functions to build [[TransactionInstruction]]\n * objects for each method of a program.\n *\n * ## Usage\n *\n * ```javascript\n * instruction.<method>(...args, ctx);\n * ```\n *\n * ## Parameters\n *\n * 1. `args` - The positional arguments for the program. The type and number\n *    of these arguments depend on the program being used.\n * 2. `ctx`  - [[Context]] non-argument parameters to pass to the method.\n *    Always the last parameter in the method call.\n *\n * ## Example\n *\n * To create an instruction for the `increment` method above,\n *\n * ```javascript\n * const tx = await program.instruction.increment({\n *   accounts: {\n *     counter,\n *   },\n * });\n * ```\n */\nexport type InstructionNamespace<\n  IDL extends Idl = Idl,\n  I extends IdlInstruction = IDL[\"instructions\"][number]\n> = MakeInstructionsNamespace<\n  IDL,\n  I,\n  TransactionInstruction,\n  {\n    [M in keyof AllInstructionsMap<IDL>]: {\n      accounts: (\n        ctx: Accounts<AllInstructionsMap<IDL>[M][\"accounts\"][number]>\n      ) => unknown;\n    };\n  }\n>;\n\n/**\n * Function to create a `TransactionInstruction` generated from an IDL.\n * Additionally it provides an `accounts` utility method, returning a list\n * of ordered accounts for the instruction.\n */\nexport type InstructionFn<\n  IDL extends Idl = Idl,\n  I extends AllInstructions<IDL> = AllInstructions<IDL>\n> = InstructionContextFn<IDL, I, TransactionInstruction> &\n  IxProps<Accounts<I[\"accounts\"][number]>>;\n\ntype IxProps<A extends Accounts> = {\n  /**\n   * Returns an ordered list of accounts associated with the instruction.\n   */\n  accounts: (ctx: A) => AccountMeta[];\n};\n\nexport type InstructionEncodeFn<I extends IdlInstruction = IdlInstruction> = (\n  ixName: I[\"name\"],\n  ix: any\n) => Buffer;\n\n// Throws error if any argument required for the `ix` is not given.\nfunction validateInstruction(ix: IdlInstruction, ...args: any[]) {\n  // todo\n}\n"]},"metadata":{},"sourceType":"module"}